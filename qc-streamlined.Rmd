---
title: "gc-tidying"
author: "Oliver M. Crook"
date: "17/06/2022"
output: html_document
---

# Introduction


# packages

```{r,}
require(S4Vectors)
require(dplyr)
require(tidyr)
require(QFeatures)
require(RColorBrewer)
require(ggplot2)
require(Peptides)
require(MASS)
require(pheatmap)
require(minpack.lm)
require(Spectra)
require(patchwork)
source("hdxincoperationFourier.R")
source("hdxmsqc-utils.R")
```

# Data

```{r,}
BRD4uncurated <- data.frame(read.csv(file = "inst/ELN55049_AllResultsTables_Uncurated.csv"))
```

Tidy dataset, which improves the formatting and converts to wide format
```{r,}
BRD4uncurated_wide <- processHDE(HDExaminerFile = BRD4uncurated, proteinStates = c("wt", "iBET"))
```
Columns with quantitative data
```{r,}
i <- grep(pattern = "X..Deut", x = names(BRD4uncurated_wide))
```

Make into a Qfeatures object
```{r,}
BRD4df <- readQFeatures(table = BRD4uncurated_wide, ecol = i, names = "Deuteration", fnames = "fnames")
```

Visualisation
```{r,}
pheatmap(assay(BRD4df), cluster_rows = FALSE, scale = "row")
```
# Examining missing values

Here, we can plot where the missing values are:
```{r,}
plotMissing(object = BRD4df)
```

Here, we can filter data that is not missing at random:
```{r,}
BRD4df_filtered <- isMissingAtRandom(object = BRD4df)
```
```{r,}
plotMissing(object = BRD4df_filtered)
```
The values that are missing are all at the zero time-points where deuterium
uptake should be 0, we can simply impute these values.

```{r,}
BRD4df_filtered_imputed <- impute(BRD4df_filtered, method = "zero")
```

# Empirical vs Theoretical errors

```{r,}
computeMassError(object = BRD4df_filtered_imputed)
plotMassError(object = BRD4df_filtered_imputed)
```

# Intensity based outlier detection

Using linear-model based outlier detection we see whether there
are Spectra that have variable intensity based on their mean intensity

```{r,}
intensityOutlier <- intensityOutliers(object = BRD4df_filtered_imputed)
plotIntensityOutliers(object = BRD4df_filtered_imputed)
```
# Retention time analysis

```{r,}
dfrt <- rTimeOutliers(object = BRD4df_filtered_imputed)
plotrTimeOutliers(object = BRD4df_filtered_imputed)
```

# Monotonicity statistics 

This uses a statistic to detect differences from monotonic behavior. First,
we need to specify the experimental design.

```{r,}
experiment <- c("wt", "iBET")
timepoints <- rep(c(0, 15, 60, 600, 3600, 14000), each = 3)
```

```{r,}
monoStat <- computeMonotoneStats(object = BRD4df_filtered_imputed,
                                 experiment = experiment, 
                                 timepoints = timepoints)
out <- plotMonotoneStat(object = BRD4df_filtered_imputed,
                                 experiment = experiment, 
                                 timepoints = timepoints)
```

# Ion Mobility Time analysis

```{r,}
imTimeOut <- imTimeOutlier(object = BRD4df_filtered_imputed)
plotImTimeOutlier(object = BRD4df_filtered_imputed)
```
# Charge state correlation

We check that charge states are correlated.

```{r,}
csCor <- chargeCorrelationHdx(object = BRD4df_filtered_imputed,
                              experiment = experiment,
                              timepoints = timepoints)
```

# Using sequence overlap information are uptake values compatible


```{r,}
tocheck <- compatibleUptake(object = BRD4df_filtered_imputed,
                 experiment = experiment,
                 timepoints = timepoints)
```
