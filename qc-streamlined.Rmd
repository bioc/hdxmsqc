---
title: "gc-tidying"
author: "Oliver M. Crook"
date: "17/06/2022"
output: html_document
---

# Introduction

The `hdxmsqc` package is a quality control assessment package
from hydrogen-deuterium exchange mass-spectrometry (HDX-MS) data. The functions
look for outliers in retention time and ion mobility. They also examine missing
values, mass errors, intensity based outliers, deviations of the data from
monotonicity, the correlation of charge states, whether uptake values
are coherent based on overlapping peptides and finally the similarity of the
observed to the theoretical spectra observed. This package is designed
to help those performing iterative quality control through manual inspection
but also a set of metric and visualizations by which practitioners can use
to demonstrate they have high quality data. 


# packages

The packages required are the following.

```{r,}
require(S4Vectors)
require(dplyr)
require(tidyr)
require(QFeatures)
require(RColorBrewer)
require(ggplot2)
require(Peptides)
require(MASS)
require(pheatmap)
require(Spectra)
require(patchwork)
source("hdxincoperationFourier.R")
source("hdxmsqc-utils.R")
```

# Data

We first load the data, as exported from HDExaminer. 

```{r,}
BRD4uncurated <- data.frame(read.csv(file = "inst/ELN55049_AllResultsTables_Uncurated.csv"))
```

The following code chunkt tidies dataset, which improves the formatting and converts
to wide format. It will also note the number of states, timepoints and peptides.
```{r,}
BRD4uncurated_wide <- processHDE(HDExaminerFile = BRD4uncurated,
                                 proteinStates = c("wt", "iBET"))
```
The next code chunk extracts the columns with the quantitative data. 
```{r,}
i <- grep(pattern = "X..Deut",
          x = names(BRD4uncurated_wide))
```

We now parse the object into an object of class `Qfeatures`. This standardises
the formatting of the data.
```{r,}
BRD4df <- readQFeatures(table = BRD4uncurated_wide,
                        ecol = i,
                        names = "Deuteration",
                        fnames = "fnames")
```

# Visualisation

A simple heatmap of our data can give us a sense of it.

```{r,}
pheatmap(assay(BRD4df), cluster_rows = FALSE, scale = "row")
```
# Examining missing values

Here, we can plot where the missing values are:
```{r,}
plotMissing(object = BRD4df)
```

Here, we can filter data that is not missing at random:
```{r,}
BRD4df_filtered <- isMissingAtRandom(object = BRD4df)
```
We can then replot missing-ness:

```{r,}
plotMissing(object = BRD4df_filtered)
```
The values that are missing are all at the zero time-points where deuterium
uptake should be 0, we can simply impute these values.

```{r,}
BRD4df_filtered_imputed <- impute(BRD4df_filtered, method = "zero")
```

# Empirical vs Theoretical errors



```{r,}
computeMassError(object = BRD4df_filtered_imputed)
plotMassError(object = BRD4df_filtered_imputed)
```

# Intensity based outlier detection

Using linear-model based outlier detection we see whether there
are Spectra that have variable intensity based on their mean intensity

```{r,}
intensityOutlier <- intensityOutliers(object = BRD4df_filtered_imputed)
plotIntensityOutliers(object = BRD4df_filtered_imputed)
```
# Retention time analysis

```{r,}
dfrt <- rTimeOutliers(object = BRD4df_filtered_imputed)
plotrTimeOutliers(object = BRD4df_filtered_imputed)
```

# Monotonicity statistics 

This uses a statistic to detect differences from monotonic behavior. First,
we need to specify the experimental design.

```{r,}
experiment <- c("wt", "iBET")
timepoints <- rep(c(0, 15, 60, 600, 3600, 14000), each = 3)
```

```{r,}
monoStat <- computeMonotoneStats(object = BRD4df_filtered_imputed,
                                 experiment = experiment, 
                                 timepoints = timepoints)
out <- plotMonotoneStat(object = BRD4df_filtered_imputed,
                                 experiment = experiment, 
                                 timepoints = timepoints)
```

# Ion Mobility Time analysis

```{r,}
imTimeOut <- imTimeOutlier(object = BRD4df_filtered_imputed)
plotImTimeOutlier(object = BRD4df_filtered_imputed)
```
# Charge state correlation

We check that charge states are correlated.

```{r,}
csCor <- chargeCorrelationHdx(object = BRD4df_filtered_imputed,
                              experiment = experiment,
                              timepoints = timepoints)
```

# Using sequence overlap information are uptake values compatible


```{r,}
tocheck <- compatibleUptake(object = BRD4df_filtered_imputed,
                 experiment = experiment,
                 timepoints = timepoints)
```

# Comparison of Spectra

Load in some Spectra from hdxsite which should match those of HDExaminer
```{r,}
hdxsite <- data.frame(read.csv("inst/BRD4_RowChecked_20220628_HDsite.csv", header = TRUE, fileEncoding = 'UTF-8-BOM'))
BRD4matched <- read.csv(file = "inst/BRD4_RowChecked_20220628_HDE.csv", header = TRUE, fileEncoding = 'UTF-8-BOM')
```

```{r,}
spectraCompare <- spectraSimilarity(peaks = hdxsite,
                                    object = BRD4matched, 
                                    experiment = experiment)
```

To visualise these spectra we can use the following function

```{r,}
plotSpectraMirror(spectraCompare$observedSpectra[1,], spectraCompare$matchedSpectra[1,], ppm = 300)
```
